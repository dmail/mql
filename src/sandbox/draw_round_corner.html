<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="data:," />

    <title>Draw corner</title>
    <style>
      canvas {
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <div id="root" style="position: relative"></div>
    <script type="module" jsenv-type="module/jsx">
      import { render } from "preact";
      import { useRef, useLayoutEffect } from "preact/hooks";
      import { useLocalStorageState } from "/app/hooks/use_local_storage_state.js";
      import {
        drawArc,
        drawLine,
        drawArcTo,
        drawQuadraticCurveTo,
      } from "/app/canvas/draw.js";

      // eslint-disable-next-line no-unused-vars
      const App = () => {
        const canvasRef = useRef();

        const [x, xSetter] = useLocalStorageState("x", 50);
        const [y, ySetter] = useLocalStorageState("y", 25);
        const [width, widthSetter] = useLocalStorageState("width", 50);
        const [height, heightSetter] = useLocalStorageState("height", 50);
        const [outerSize, outerSizeSetter] = useLocalStorageState(
          "outer_size",
          1,
        );
        const [innerSize, innerSizeSetter] = useLocalStorageState(
          "inner_size",
          1,
        );
        const [radius, radiusSetter] = useLocalStorageState("radius", 10);
        const [topLeft, topLeftSetter] = useLocalStorageState("topLeft", true);
        const [topRight, topRightSetter] = useLocalStorageState(
          "topRight",
          true,
        );
        const [bottomRight, bottomRightSetter] = useLocalStorageState(
          "bottomRight",
          true,
        );
        const [bottomLeft, bottomLeftSetter] = useLocalStorageState(
          "bottomLeft",
          true,
        );

        const drawArcs = (canvas) => {
          const context = canvas.getContext("2d");
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.imageSmoothingEnabled = false;
          const outerColor = "green";
          const outerOpacity = 0.5;
          const innerColor = "red";
          const innerOpacity = 0.5;

          const center = [
            x + radius + outerSize / 2,
            y + radius + outerSize / 2,
          ];

          outer: {
            let outerRadius = radius;
            context.beginPath();
            context.lineWidth = outerSize;
            if (topLeft) {
              drawTopLeftCorner(context, {
                x,
                y,
                center,
                radius: outerRadius,
                size: outerSize,
                width,
                height,
              });
            }
            context.globalAlpha = outerOpacity;
            context.strokeStyle = outerColor;
            context.stroke();
          }

          inner: {
            let innerRadius = 2;
            context.beginPath();
            context.lineWidth = innerSize;
            drawLine(
              context,
              [x + outerSize, y + outerSize],
              [x + width, y + outerSize],
            );
            context.strokStyle = outerColor;
            context.stroke();

            context.beginPath();
            context.lineWidth = outerSize;
            if (topLeft) {
              drawTopLeftCorner(context, {
                x: x + outerSize,
                y: y + outerSize,
                center,
                radius: Math.max(innerRadius, 0),
                size: innerSize,
                width: width - outerSize,
                height: height - outerSize,
              });
            }

            context.globalAlpha = innerOpacity;
            context.strokeStyle = innerColor;
            context.stroke();
          }

          one_more: {
            let subRadius =
              radius -
              outerSize / 2 -
              innerSize / 2 -
              innerSize / 2 -
              innerSize / 2;
            context.beginPath();
            context.lineWidth = innerSize;
            if (topLeft) {
              drawTopLeftCorner(context, {
                x: x + outerSize + innerSize,
                y: y + outerSize + innerSize,
                center,
                radius: Math.max(subRadius, 0),
                size: innerSize,
                width: width - outerSize - innerSize,
                height: height - outerSize - innerSize,
              });
            }
            context.globalAlpha = innerOpacity;
            context.strokeStyle = "blue";
            context.stroke();
          }
        };

        const drawTopLeftCorner = (
          context,
          { x, y, width, height, center, radius, size },
        ) => {
          const leftLineX = x + size / 2;
          if (radius === 0) {
            drawLine(context, [x, y + size / 2], [x + width, y + size / 2]);
            drawLine(context, [leftLineX, y + size], [leftLineX, y + height]);
            return;
          }

          let topLineXStart = x + radius + size / 2;
          let topLineY = y + size / 2;
          const topLineStart = [topLineXStart, topLineY];
          const topLineEnd = [x + width, topLineY];

          const leftLineStart = [leftLineX, y + radius + size / 2];
          const leftLineEnd = [leftLineX, y + height];
          drawQuadraticCurveTo(
            context,
            leftLineStart,
            [x + size / 2, y + size / 2],
            topLineStart,
          );
          //  drawArc(context, center, radius, 180, 270);
          drawLine(context, topLineStart, topLineEnd);
          drawLine(context, leftLineStart, leftLineEnd);
        };

        useLayoutEffect(() => {
          drawArcs(canvasRef.current);
        }, [
          x,
          y,
          width,
          height,
          outerSize,
          innerSize,
          radius,
          topLeft,
          topRight,
          bottomRight,
          bottomLeft,
        ]);

        return (
          <div>
            <canvas ref={canvasRef} width="100" height="100"></canvas>
            <fieldset>
              <legend>General</legend>

              <label>
                x:
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={x}
                  onInput={(e) => {
                    if (!isNaN(e.target.valueAsNumber)) {
                      xSetter(e.target.valueAsNumber);
                    }
                  }}
                />
              </label>
              <label>
                y:
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={y}
                  onInput={(e) => {
                    if (!isNaN(e.target.valueAsNumber)) {
                      ySetter(e.target.valueAsNumber);
                    }
                  }}
                />
              </label>
              <br />
              <label>
                radius:
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={radius}
                  onInput={(e) => radiusSetter(e.target.valueAsNumber)}
                />
              </label>
              <br />
              <label>
                width:
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={width}
                  onInput={(e) => widthSetter(e.target.valueAsNumber)}
                />
              </label>
              <label>
                height:
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={height}
                  onInput={(e) => heightSetter(e.target.valueAsNumber)}
                />
              </label>
              <br />
              <label>
                top left:
                <input
                  type="checkbox"
                  checked={topLeft}
                  onChange={(e) => topLeftSetter(e.target.checked)}
                />
              </label>
              <label>
                top right:
                <input
                  type="checkbox"
                  checked={topRight}
                  onChange={(e) => topRightSetter(e.target.checked)}
                />
              </label>
              <label>
                bottom right:
                <input
                  type="checkbox"
                  checked={bottomRight}
                  onChange={(e) => bottomRightSetter(e.target.checked)}
                />
              </label>
              <label>
                bottom left:
                <input
                  type="checkbox"
                  checked={bottomLeft}
                  onChange={(e) => bottomLeftSetter(e.target.checked)}
                />
              </label>
            </fieldset>
            <fieldset>
              <legend>Outer</legend>
              <label>
                size:
                <input
                  type="number"
                  min="1"
                  max="100"
                  value={outerSize}
                  onInput={(e) => outerSizeSetter(e.target.valueAsNumber)}
                />
              </label>
            </fieldset>
            <fieldset>
              <legend>Inner</legend>
              <label>
                size:
                <input
                  type="number"
                  min="1"
                  max="100"
                  value={innerSize}
                  onInput={(e) => innerSizeSetter(e.target.valueAsNumber)}
                />
              </label>
            </fieldset>
          </div>
        );
      };

      render(<App />, document.querySelector("#root"));
    </script>
  </body>
</html>
